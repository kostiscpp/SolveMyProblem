Installing dependencies for Orchestrator Service...

up to date, audited 147 packages in 1s

17 packages are looking for funding
  run `npm fund` for details

5 vulnerabilities (2 moderate, 3 high)

To address all issues, run:
  npm audit fix

Run `npm audit` for details.
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 1s

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
node:events:497
      throw er; // Unhandled 'error' event
      ^

Error: listen EADDRINUSE: address already in use :::6900
    at Server.setupListenHandle [as _listen2] (node:net:1893:16)
    at listenInCluster (node:net:1941:12)
    at Server.listen (node:net:2029:7)
    at Function.listen (C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\node_modules\express\lib\application.js:635:24)
    at Object.<anonymous> (C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\orchestrator\app.js:93:5)
    at Module._compile (node:internal/modules/cjs/loader:1378:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1437:10)
    at Module.load (node:internal/modules/cjs/loader:1212:32)
    at Module._load (node:internal/modules/cjs/loader:1028:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:142:12)
Emitted 'error' event on Server instance at:
    at emitErrorNT (node:net:1920:8)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {
  code: 'EADDRINUSE',
  errno: -4091,
  syscall: 'listen',
  address: '::',
  port: 6900
}

Node.js v21.6.1
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 905ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Sending login request to user-service, correlationId: 641cf184-07ef-487f-9e2d-0aea54d96c50
Message sent to queue: user-service-queue
Sending credit update request to user-service, correlationId: d15808f9-b348-4553-81ce-e5fc7cb4a539
Message sent to queue: user-service-queue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: '6fsf6e',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 964ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Sending login request to user-service, correlationId: 611d88ce-755e-45ce-b99d-5707d2923a21
Message sent to queue: user-service-queue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'vugtsa',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 1s

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Sending login request to user-service, correlationId: bc9cdac5-ae2e-4b8e-bd19-a9eb91299c89
Message sent to queue: user-service-queue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'hud9z',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 925ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 1s

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Sending login request to user-service, correlationId: a06d8550-2350-4cd9-b966-9e3ae307ed89
Message sent to queue: user-service-queue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: '7jkzz6',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 906ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Sending login request to user-service, correlationId: 50f23402-2823-47b4-b75d-341bffef94ff
Message sent to queue: user-service-queue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'tuqmdh',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 889ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Sending login request to user-service, correlationId: 51c94795-9dde-4852-bb46-fb59f6f2700c
Message sent to queue: user-service-queue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'b23nrk',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Message sent to queue: problem-service-issue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 924ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Sending login request to user-service, correlationId: eee2e9e8-3935-446c-81b7-eb775edf2d7f
Message sent to queue: user-service-queue
Sending login request to user-service, correlationId: d2c8d5b8-3cab-48f5-acdf-bd58a230b8ab
Message sent to queue: user-service-queue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'w6ib',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 978ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Sending login request to user-service, correlationId: 5620ae93-6079-4da2-84fd-fbdefa799948
Message sent to queue: user-service-queue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: '2eu8tf',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 940ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Sending login request to user-service, correlationId: dcfe9e4a-5c6d-4c4e-aed6-b5971c3ceb20
Message sent to queue: user-service-queue
Sending login request to user-service, correlationId: 03898e2b-40df-499f-84e2-8b4df4688cba
Message sent to queue: user-service-queue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'l48et9',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 917ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Sending login request to user-service, correlationId: 381ef870-05eb-4080-8353-7581f544aa41
Message sent to queue: user-service-queue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'fbi4buj',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Message sent to queue: problem-service-issue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 899ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Sending login request to user-service, correlationId: 2381f655-c5f3-4630-ae90-1e290a0ba738
Message sent to queue: user-service-queue
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: '8abtp',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 871ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Sending login request to user-service, correlationId: ec078b0f-5141-4b14-a52d-576746d6357f
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: '1veclm',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: problem-service-issue
Full request body: {
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 882ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Full request body: {
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to user-service-credit-req with User ID: 66eeb10160acf2e6890094f9
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'h451ba',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: problem-service-issue
Sending login request to user-service, correlationId: 96c5c17d-e389-4725-b24f-ba28dd4f8c2e
Message sent to queue: user-service-queue
Sending login request to user-service, correlationId: 0674439d-8c80-4e0a-ad59-c41c82c6f276
Message sent to queue: user-service-queue
Sending login request to user-service, correlationId: dfe9fcd6-2dc1-4ed2-8e55-6a01aeec02d6
Message sent to queue: user-service-queue
Sending login request to user-service, correlationId: 54c1642f-3785-4d48-91db-19866297fda2
Message sent to queue: user-service-queue
Sending login request to user-service, correlationId: 4255976e-e8db-42bc-9480-03fe33a01194
Message sent to queue: user-service-queue
Sending login request to user-service, correlationId: 18f6d516-a016-4cec-884d-bec4e7124f4d
Message sent to queue: user-service-queue
Sending login request to user-service, correlationId: 1174c80e-559d-498a-ae1e-4e2f0b05d39a
Message sent to queue: user-service-queue
Sending login request to user-service, correlationId: 2ee5d84b-26c1-4901-8c89-f49eb0cbccb2
Message sent to queue: user-service-queue
Sending login request to user-service, correlationId: 901d2872-71fa-4edb-a9a6-549eda19e999
Message sent to queue: user-service-queue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 884ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: '2uldf',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 892ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: user-service-credit-req
Consuming from queue: user-service-credit-res
Error in problem issue saga: SyntaxError: "[object Object]" is not valid JSON
    at JSON.parse (<anonymous>)
    at exports.problemIssue (C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\orchestrator\controllers\problemIssue.js:153:43)
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 1s

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: user-service-credit-req
Consuming from queue: user-service-credit-res
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 865ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: user-service-credit-req
Consuming from queue: user-service-credit-res
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: problem-service-issue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: user-service-credit-req
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: user-service-credit-req
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: user-service-credit-req
Consuming from queue: user-service-credit-res
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 874ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: '116axf',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 879ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Consuming from queue: probMan-to-orch-queue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 928ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Consuming from queue: probMan-to-orch-queue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 1,
  "maxDistance": 50000,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'apzwxk',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 1,
  "maxDistance": 50000,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Message sent to queue: problem-service-issue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 905ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Consuming from queue: probMan-to-orch-queue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'hlvxal',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Message sent to queue: problem-service-issue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 889ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Consuming from queue: probMan-to-orch-queue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'urueak',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Message sent to queue: problem-service-issue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 979ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Consuming from queue: probMan-to-orch-queue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'ihifc',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Message sent to queue: problem-service-issue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 876ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Consuming from queue: probMan-to-orch-queue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'ay8lha',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Message sent to queue: problem-service-issue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 915ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Consuming from queue: probMan-to-orch-queue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: 'iavuw4',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Message sent to queue: problem-service-issue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 993ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Consuming from queue: probMan-to-orch-queue
Message sent to queue: user-service-queue
Installing dependencies for Orchestrator Service...

up to date, audited 155 packages in 983ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Orchestrator Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/orchestrator" && node app.js
Server running on port 6900
Consuming from queue: user-service-queue-res
Consuming from queue: trans_response_queue
Consuming from queue: probMan-to-orch-queue
Message sent to queue: user-service-queue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Received message from user-service-credit-res: {
  correlationId: '3vg11',
  success: true,
  message: 'Credit deducted successfully'
}
User has sufficient credits, sending problem to problem-service-issue queue
Sending to problem-service-issue: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Message sent to queue: problem-service-issue
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
Full request body: {
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
Sending message to user-service-credit-req with User ID: 66ef3875b89a43c218455536
Message sent to queue: user-service-credit-req
Sent message to user-service-credit-req queue
Consuming from queue: user-service-credit-res
