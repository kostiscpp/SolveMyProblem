Installing dependencies for Solver Service...

up to date, audited 147 packages in 943ms

17 packages are looking for funding
  run `npm fund` for details

5 vulnerabilities (2 moderate, 3 high)

To address all issues, run:
  npm audit fix

Run `npm audit` for details.
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Installing dependencies for Solver Service...

up to date, audited 155 packages in 899ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Installing dependencies for Solver Service...

up to date, audited 155 packages in 925ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Installing dependencies for Solver Service...

up to date, audited 155 packages in 909ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Installing dependencies for Solver Service...

up to date, audited 155 packages in 977ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Installing dependencies for Solver Service...

up to date, audited 155 packages in 880ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Installing dependencies for Solver Service...

up to date, audited 155 packages in 933ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef2e3ef93ec5c2e027eea8',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef2e3ef93ec5c2e027eea8',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 994ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef2fbc48f08f58176bdc4d',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef2fbc48f08f58176bdc4d',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 902ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Installing dependencies for Solver Service...

up to date, audited 155 packages in 912ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef31a2aca4ebfbc1aac8ee',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef31a2aca4ebfbc1aac8ee',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef31d5aca4ebfbc1aac8f0',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef31d5aca4ebfbc1aac8f0',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 910ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef34008e6ada82daa2eb8c',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef34008e6ada82daa2eb8c',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 968ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef353215ab3765b55ab318',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef353215ab3765b55ab318',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 934ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Installing dependencies for Solver Service...

up to date, audited 155 packages in 883ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef363e4e5666545318b1c3',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef363e4e5666545318b1c3',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef36594e5666545318b1c5',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef36594e5666545318b1c5',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 896ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef379b57596069bdd5b7d2',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef379b57596069bdd5b7d2',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 877ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef37f5e5c6cc72feca27b6',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef37f5e5c6cc72feca27b6',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Consuming from queue: probMan-to-solver-queue
Installing dependencies for Solver Service...

up to date, audited 155 packages in 883ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef3897a77aa70e36e99744',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef3897a77aa70e36e99744',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 874ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Installing dependencies for Solver Service...

up to date, audited 155 packages in 884ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef5081bddb050f63203347',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef5081bddb050f63203347',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 881ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef51888477096353a5fe6f',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef51888477096353a5fe6f',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 865ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66ef538d94423429b7e48ec5',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields in the message: {
  problemId: '66ef538d94423429b7e48ec5',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 932ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Installing dependencies for Solver Service...

up to date, audited 155 packages in 903ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66effde8cb0c1d3079b931a9',
  numVehicles: 3,
  depot: 1,
  maxDistance: 50000,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Processing problem: {
  problemId: '66effde8cb0c1d3079b931a9',
  numVehicles: 3,
  depot: 1,
  maxDistance: 50000,
  locationFileName: undefined,
  locationFileContent: { Locations: [ [Object], [Object] ] }
}
Creating upload directory at C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\solver-service\uploads
Saving location file to: C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\solver-service\uploads\location_66effde8cb0c1d3079b931a9.json
Location file saved successfully.
Executing command: python3 vrpSolver.py C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\solver-service\uploads\location_66effde8cb0c1d3079b931a9.json 3 1 50000
Error executing command: Error: Command failed: python3 vrpSolver.py C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\solver-service\uploads\location_66effde8cb0c1d3079b931a9.json 3 1 50000
Python was not found; run without arguments to install from the Microsoft Store, or disable this shortcut from Settings > Manage App Execution Aliases.

    at genericNodeError (node:internal/errors:984:15)
    at wrappedFn (node:internal/errors:538:14)
    at ChildProcess.exithandler (node:child_process:422:12)
    at ChildProcess.emit (node:events:519:28)
    at maybeClose (node:internal/child_process:1105:16)
    at ChildProcess._handle.onexit (node:internal/child_process:305:5) {
  code: 9009,
  killed: false,
  signal: null,
  cmd: 'python3 vrpSolver.py C:\\Users\\user\\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\\Έγγραφα\\GitHub\\saasv2\\saas2024-24\\solver-service\\uploads\\location_66effde8cb0c1d3079b931a9.json 3 1 50000'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 898ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66f0029cd7642f8e838e33d1',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Missing required fields in the message: {
  problemId: '66f0029cd7642f8e838e33d1',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 873ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66f0031a372bf827ff2eacd7',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: {
    Locations: [
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object]
    ]
  },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Missing required fields in the message: {
  problemId: '66f0031a372bf827ff2eacd7',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: {
    Locations: [
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object]
    ]
  },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 888ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66f003efde8254eebdc93c05',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Missing required fields in the message: {
  problemId: '66f003efde8254eebdc93c05',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 873ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66f0046d26b889f8b15fe60d',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: {
    Locations: [
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object]
    ]
  },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Missing required fields in the message: {
  problemId: '66f0046d26b889f8b15fe60d',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: {
    Locations: [
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object]
    ]
  },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 895ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66f005d86aa6b972d7dc4447',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Missing required fields in the message: {
  problemId: '66f005d86aa6b972d7dc4447',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Installing dependencies for Solver Service...

up to date, audited 155 packages in 889ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Installing dependencies for Solver Service...

up to date, audited 155 packages in 889ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Solver Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/solver-service" && node solver.js
Connected to RabbitMQ
Waiting for messages in probMan-to-solver-queue
Consuming from queue: probMan-to-solver-queue
Received message from probMan-to-solver-queue: {
  problemId: '66f009369538cb7f6406f023',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: {
    Locations: [
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object]
    ]
  },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Missing required fields in the message: {
  problemId: '66f009369538cb7f6406f023',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: {
    Locations: [
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object]
    ]
  },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
