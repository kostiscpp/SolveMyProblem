Installing dependencies for Problem Management Service...

up to date, audited 147 packages in 933ms

17 packages are looking for funding
  run `npm fund` for details

5 vulnerabilities (2 moderate, 3 high)

To address all issues, run:
  npm audit fix

Run `npm audit` for details.
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:11660) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:11660) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Connected to RabbitMQ
Attempting to consume from queue: problem-service-issue
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 893ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:11712) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:11712) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
node:events:497
      throw er; // Unhandled 'error' event
      ^

Error: listen EADDRINUSE: address already in use :::5000
    at Server.setupListenHandle [as _listen2] (node:net:1893:16)
    at listenInCluster (node:net:1941:12)
    at Server.listen (node:net:2029:7)
    at Function.listen (C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\node_modules\express\lib\application.js:635:24)
    at Object.<anonymous> (C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\problem-management-service\app.js:61:5)
    at Module._compile (node:internal/modules/cjs/loader:1378:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1437:10)
    at Module.load (node:internal/modules/cjs/loader:1212:32)
    at Module._load (node:internal/modules/cjs/loader:1028:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:142:12)
Emitted 'error' event on Server instance at:
    at emitErrorNT (node:net:1920:8)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {
  code: 'EADDRINUSE',
  errno: -4091,
  syscall: 'listen',
  address: '::',
  port: 5000
}

Node.js v21.6.1
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 949ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:31528) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:31528) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Processing problem issue message...
Raw message received: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 907ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:4796) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:4796) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Connected to RabbitMQ
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Processing problem issue message...
Raw message received: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 1s

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:22144) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:22144) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Processing problem issue message...
Raw message received: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Missing required fields
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 933ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:23960) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:23960) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 1s

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:29968) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:29968) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Problem saved successfully: {
  userId: new ObjectId('66eeb10160acf2e6890094f9'),
  locationFile: '{"Locations":[{"Latitude":37.999833,"Longitude":23.743177},{"Latitude":37.966783,"Longitude":23.778605}]}',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  submissionDate: 2024-09-21T20:36:14.003Z,
  status: 'pending',
  hasSolution: false,
  solution: '',
  maxRouteDistance: 0,
  totalDistTravel: 0,
  executionDuration: 0,
  _id: new ObjectId('66ef2e3ef93ec5c2e027eea8'),
  __v: 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef2e3ef93ec5c2e027eea8',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 918ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:34284) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:34284) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Connected to RabbitMQ
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Problem saved successfully: {
  userId: new ObjectId('66eeb10160acf2e6890094f9'),
  locationFile: '{"Locations":[{"Latitude":37.999833,"Longitude":23.743177},{"Latitude":37.966783,"Longitude":23.778605}]}',
  pythonFile: 'Python code here',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  submissionDate: 2024-09-21T20:42:36.682Z,
  status: 'pending',
  hasSolution: false,
  solution: '',
  maxRouteDistance: 0,
  totalDistTravel: 0,
  executionDuration: 0,
  _id: new ObjectId('66ef2fbc48f08f58176bdc4d'),
  __v: 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef2fbc48f08f58176bdc4d',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 899ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\node_modules\express\lib\router\route.js:216
        throw new Error(msg);
        ^

Error: Route.post() requires a callback function but got a [object Undefined]
    at Route.<computed> [as post] (C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\node_modules\express\lib\router\route.js:216:15)
    at proto.<computed> [as post] (C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\node_modules\express\lib\router\index.js:521:19)
    at Object.<anonymous> (C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\problem-management-service\routes\dataRoutes.js:11:8)
    at Module._compile (node:internal/modules/cjs/loader:1378:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1437:10)
    at Module.load (node:internal/modules/cjs/loader:1212:32)
    at Module._load (node:internal/modules/cjs/loader:1028:12)
    at Module.require (node:internal/modules/cjs/loader:1237:19)
    at require (node:internal/modules/helpers:176:18)
    at Object.<anonymous> (C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\problem-management-service\app.js:69:20)

Node.js v21.6.1
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 892ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:37632) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:37632) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Problem saved successfully: {
  "userId": "66eeb10160acf2e6890094f9",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T20:50:42.548Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef31a2aca4ebfbc1aac8ee",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef31a2aca4ebfbc1aac8ee',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Problem saved successfully: {
  "userId": "66eeb10160acf2e6890094f9",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T20:51:33.247Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef31d5aca4ebfbc1aac8f0",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef31d5aca4ebfbc1aac8f0',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 888ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:17228) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:17228) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Problem saved successfully: {
  "userId": "66eeb10160acf2e6890094f9",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T21:00:48.987Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef34008e6ada82daa2eb8c",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef34008e6ada82daa2eb8c',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 989ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:31852) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:31852) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Problem saved successfully: {
  "userId": "66eeb10160acf2e6890094f9",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T21:05:54.918Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef353215ab3765b55ab318",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef353215ab3765b55ab318',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 961ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\problem-management-service\controllers\problemIssue.js:297
const Problem = require('../models/problemModel');
      ^

SyntaxError: Identifier 'Problem' has already been declared
    at internalCompileFunction (node:internal/vm:77:18)
    at wrapSafe (node:internal/modules/cjs/loader:1290:20)
    at Module._compile (node:internal/modules/cjs/loader:1342:27)
    at Module._extensions..js (node:internal/modules/cjs/loader:1437:10)
    at Module.load (node:internal/modules/cjs/loader:1212:32)
    at Module._load (node:internal/modules/cjs/loader:1028:12)
    at Module.require (node:internal/modules/cjs/loader:1237:19)
    at require (node:internal/modules/helpers:176:18)
    at Object.<anonymous> (C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\problem-management-service\routes\dataRoutes.js:3:24)
    at Module._compile (node:internal/modules/cjs/loader:1378:14)

Node.js v21.6.1
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 946ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:36496) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:36496) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Connected to RabbitMQ
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.999833,
      "Longitude": 23.743177
    },
    {
      "Latitude": 37.966783,
      "Longitude": 23.778605
    }
  ]
}
pythonFileContent: Python code here
Problem to be saved: {
  "userId": "66eeb10160acf2e6890094f9",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T21:10:22.337Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef363e4e5666545318b1c3"
}
Problem saved successfully: {
  "userId": "66eeb10160acf2e6890094f9",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T21:10:22.337Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef363e4e5666545318b1c3",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef363e4e5666545318b1c3',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.999833,
      "Longitude": 23.743177
    },
    {
      "Latitude": 37.966783,
      "Longitude": 23.778605
    }
  ]
}
pythonFileContent: Python code here
Problem to be saved: {
  "userId": "66eeb10160acf2e6890094f9",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T21:10:49.335Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef36594e5666545318b1c5"
}
Problem saved successfully: {
  "userId": "66eeb10160acf2e6890094f9",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T21:10:49.335Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef36594e5666545318b1c5",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef36594e5666545318b1c5',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 897ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:33360) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:33360) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.999833,
      "Longitude": 23.743177
    },
    {
      "Latitude": 37.966783,
      "Longitude": 23.778605
    }
  ]
}
pythonFileContent: Python code here
Problem to be saved: {
  "userId": "66eeb10160acf2e6890094f9",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T21:16:11.691Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef379b57596069bdd5b7d2"
}
Problem saved successfully: {
  "userId": "66eeb10160acf2e6890094f9",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T21:16:11.691Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef379b57596069bdd5b7d2",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef379b57596069bdd5b7d2',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 887ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:2768) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:2768) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Connected to RabbitMQ
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66eeb10160acf2e6890094f9',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66eeb10160acf2e6890094f9",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.999833,
      "Longitude": 23.743177
    },
    {
      "Latitude": 37.966783,
      "Longitude": 23.778605
    }
  ]
}
pythonFileContent: Python code here
Problem to be saved: {
  "userId": "66eeb10160acf2e6890094f9",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T21:17:41.391Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef37f5e5c6cc72feca27b6"
}
Problem saved successfully: {
  "userId": "66eeb10160acf2e6890094f9",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T21:17:41.391Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef37f5e5c6cc72feca27b6",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef37f5e5c6cc72feca27b6',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 896ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:32068) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:32068) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66ef3875b89a43c218455536',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.999833,
      "Longitude": 23.743177
    },
    {
      "Latitude": 37.966783,
      "Longitude": 23.778605
    }
  ]
}
pythonFileContent: Python code here
Problem to be saved: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T21:20:23.447Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef3897a77aa70e36e99744"
}
Problem saved successfully: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T21:20:23.447Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef3897a77aa70e36e99744",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef3897a77aa70e36e99744',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 881ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:36148) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:36148) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Connected to RabbitMQ
Attempting to consume from queue: problem-service-issue
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 876ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:2432) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:2432) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66ef3875b89a43c218455536',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received in problem management service: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Problem to be saved: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": "{\"Locations\":[{\"Latitude\":37.999833,\"Longitude\":23.743177},{\"Latitude\":37.966783,\"Longitude\":23.778605}]}",
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T23:02:25.789Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef5081bddb050f63203347"
}
Problem saved successfully: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": "{\"Locations\":[{\"Latitude\":37.999833,\"Longitude\":23.743177},{\"Latitude\":37.966783,\"Longitude\":23.778605}]}",
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T23:02:25.789Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef5081bddb050f63203347",
  "__v": 0
}
Sending to solver queue: {
  "problemId": "66ef5081bddb050f63203347",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef5081bddb050f63203347',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 886ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:29968) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:29968) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66ef3875b89a43c218455536',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received in problem management service: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Extracted locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.999833,
      "Longitude": 23.743177
    },
    {
      "Latitude": 37.966783,
      "Longitude": 23.778605
    }
  ]
}
Extracted pythonFileContent: Python code here
Problem to be saved: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": "{\"Locations\":[{\"Latitude\":37.999833,\"Longitude\":23.743177},{\"Latitude\":37.966783,\"Longitude\":23.778605}]}",
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T23:06:48.245Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef51888477096353a5fe6f"
}
Problem saved successfully: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": "{\"Locations\":[{\"Latitude\":37.999833,\"Longitude\":23.743177},{\"Latitude\":37.966783,\"Longitude\":23.778605}]}",
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T23:06:48.245Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef51888477096353a5fe6f",
  "__v": 0
}
Sending to solver queue: {
  "problemId": "66ef51888477096353a5fe6f",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef51888477096353a5fe6f',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 1s

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:27328) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:27328) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66ef3875b89a43c218455536',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received in problem management service: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Extracted locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.999833,
      "Longitude": 23.743177
    },
    {
      "Latitude": 37.966783,
      "Longitude": 23.778605
    }
  ]
}
Extracted pythonFileContent: Python code here
Problem to be saved: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": "{\"Locations\":[{\"Latitude\":37.999833,\"Longitude\":23.743177},{\"Latitude\":37.966783,\"Longitude\":23.778605}]}",
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T23:15:25.656Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef538d94423429b7e48ec5"
}
Problem saved successfully: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": "{\"Locations\":[{\"Latitude\":37.999833,\"Longitude\":23.743177},{\"Latitude\":37.966783,\"Longitude\":23.778605}]}",
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-21T23:15:25.656Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66ef538d94423429b7e48ec5",
  "__v": 0
}
Sending to solver queue: {
  "problemId": "66ef538d94423429b7e48ec5",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66ef538d94423429b7e48ec5',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 905ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\problem-management-service\controllers\problemIssue.js:351
module.exports = { submitData };
                   ^

ReferenceError: submitData is not defined
    at Object.<anonymous> (C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\problem-management-service\controllers\problemIssue.js:351:20)
    at Module._compile (node:internal/modules/cjs/loader:1378:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1437:10)
    at Module.load (node:internal/modules/cjs/loader:1212:32)
    at Module._load (node:internal/modules/cjs/loader:1028:12)
    at Module.require (node:internal/modules/cjs/loader:1237:19)
    at require (node:internal/modules/helpers:176:18)
    at Object.<anonymous> (C:\Users\user\OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο\Έγγραφα\GitHub\saasv2\saas2024-24\problem-management-service\routes\dataRoutes.js:3:24)
    at Module._compile (node:internal/modules/cjs/loader:1378:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1437:10)

Node.js v21.6.1
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 895ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:39256) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:39256) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Connected to RabbitMQ
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66ef3875b89a43c218455536',
  numVehicles: 3,
  depot: 1,
  maxDistance: 50000,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 1,
  "maxDistance": 50000,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFileContent": "Python code here"
}
locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.999833,
      "Longitude": 23.743177
    },
    {
      "Latitude": 37.966783,
      "Longitude": 23.778605
    }
  ]
}
pythonFileContent: Python code here
Problem to be saved: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 1,
  "maxDistance": 50000,
  "submissionDate": "2024-09-22T11:22:16.077Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66effde8cb0c1d3079b931a9"
}
Problem saved successfully: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.999833,
        "Longitude": 23.743177
      },
      {
        "Latitude": 37.966783,
        "Longitude": 23.778605
      }
    ]
  },
  "pythonFile": "Python code here",
  "numVehicles": 3,
  "depot": 1,
  "maxDistance": 50000,
  "submissionDate": "2024-09-22T11:22:16.077Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66effde8cb0c1d3079b931a9",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66effde8cb0c1d3079b931a9',
  numVehicles: 3,
  depot: 1,
  maxDistance: 50000,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'Python code here'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 885ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:19376) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:19376) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66ef3875b89a43c218455536',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.99983328183838,
      "Longitude": 23.74317714798427
    },
    {
      "Latitude": 37.97827880279073,
      "Longitude": 23.75884558944574
    }
  ]
}
pythonFileContent: import json
import os
import sys
from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp
from math import radians, sin, cos, sqrt, atan2

def haversine_distance(lat1, lon1, lat2, lon2):
    """Calculate the great-circle distance between two points on the Earth's surface."""
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    distance = 6371 * c  # Earth radius in kilometers
    return int(round(1000 * distance))

def calculate_distance_matrix(locations):
    num_locations = len(locations)
    distance_matrix = [[0]*num_locations for _ in range(num_locations)]
    for i in range(num_locations):
        for j in range(num_locations):
            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']
            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']
            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)
    return distance_matrix

def create_data_model(locations, num_vehicles, depot):
    data = {}
    data["distance_matrix"] = calculate_distance_matrix(locations)
    data["num_vehicles"] = num_vehicles
    data["depot"] = depot
    return data

def print_solution(data, manager, routing, solution):
    print(f"Objective: {solution.ObjectiveValue()}")
    max_route_distance = 0
    for vehicle_id in range(data["num_vehicles"]):
        index = routing.Start(vehicle_id)
        plan_output = f"Route for vehicle {vehicle_id}:
"
        route_distance = 0
        while not routing.IsEnd(index):
            plan_output += f" {manager.IndexToNode(index)} -> "
            previous_index = index
            index = solution.Value(routing.NextVar(index))
            route_distance += routing.GetArcCostForVehicle(
                previous_index, index, vehicle_id
            )
        plan_output += f"{manager.IndexToNode(index)}
"
        plan_output += f"Distance of the route: {route_distance}m
"
        print(plan_output)
        max_route_distance = max(route_distance, max_route_distance)
    print(f"Maximum of the route distances: {max_route_distance}m")

def read_json_file(file_path):
    with open(file_path, 'r') as file:
        data = json.load(file)
        return data.get('Locations', [])

def main():
    if len(sys.argv) != 5:
        print("Wrong number of args.
Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")
        sys.exit(1)
    input_file = os.path.abspath(sys.argv[1])  # Get absolute path
    num_vehicles = int(sys.argv[2])
    depot = int(sys.argv[3])
    max_distance = int(sys.argv[4])
    locations = read_json_file(input_file)
    data = create_data_model(locations, num_vehicles, depot)
    manager = pywrapcp.RoutingIndexManager(
        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]
    )
    routing = pywrapcp.RoutingModel(manager)
    def distance_callback(from_index, to_index):
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data["distance_matrix"][from_node][to_node]
    transit_callback_index = routing.RegisterTransitCallback(distance_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
    dimension_name = "Distance"
    routing.AddDimension(
        transit_callback_index,
        0,  # no slack
        max_distance,  # vehicle maximum travel distance
        True,  # start cumul to zero
        dimension_name,
    )
    distance_dimension = routing.GetDimensionOrDie(dimension_name)
    distance_dimension.SetGlobalSpanCostCoefficient(100)
    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
    )
    solution = routing.SolveWithParameters(search_parameters)
    if solution:
        print_solution(data, manager, routing, solution)
    else:
        print("No solution found !")

if __name__ == "__main__":
    main()
Problem to be saved: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFile": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-22T11:42:20.719Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66f0029cd7642f8e838e33d1"
}
Problem saved successfully: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFile": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-22T11:42:20.719Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66f0029cd7642f8e838e33d1",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66f0029cd7642f8e838e33d1',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 871ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:33960) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:33960) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Connected to RabbitMQ
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66ef3875b89a43c218455536',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: {
    Locations: [
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object]
    ]
  },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.99983328183838,
      "Longitude": 23.74317714798427
    },
    {
      "Latitude": 37.966783510525985,
      "Longitude": 23.778605533642235
    },
    {
      "Latitude": 37.9990464764814,
      "Longitude": 23.773251398190194
    },
    {
      "Latitude": 37.974070236340665,
      "Longitude": 23.737519890565082
    },
    {
      "Latitude": 37.99763705556787,
      "Longitude": 23.76632669971703
    },
    {
      "Latitude": 37.987158185269436,
      "Longitude": 23.760040398809927
    },
    {
      "Latitude": 37.96565952612894,
      "Longitude": 23.78044816563277
    },
    {
      "Latitude": 38.00816194011881,
      "Longitude": 23.743726736188382
    },
    {
      "Latitude": 37.983474656462256,
      "Longitude": 23.73256864917707
    },
    {
      "Latitude": 37.96362413346355,
      "Longitude": 23.77785820154608
    },
    {
      "Latitude": 37.96581060070882,
      "Longitude": 23.72133687257313
    },
    {
      "Latitude": 37.97624293546459,
      "Longitude": 23.740238201740137
    },
    {
      "Latitude": 38.00566809733227,
      "Longitude": 23.728089082692076
    },
    {
      "Latitude": 38.00132387722171,
      "Longitude": 23.75830400972441
    },
    {
      "Latitude": 37.96320247915091,
      "Longitude": 23.785174964462342
    },
    {
      "Latitude": 37.965357705819066,
      "Longitude": 23.74320004992697
    },
    {
      "Latitude": 37.9692186084866,
      "Longitude": 23.785110852487332
    },
    {
      "Latitude": 37.98271697637991,
      "Longitude": 23.73542153051244
    },
    {
      "Latitude": 37.97230013076112,
      "Longitude": 23.788423933330492
    },
    {
      "Latitude": 37.97827880279073,
      "Longitude": 23.75884558944574
    }
  ]
}
pythonFileContent: import json
import os
import sys
from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp
from math import radians, sin, cos, sqrt, atan2

def haversine_distance(lat1, lon1, lat2, lon2):
    """Calculate the great-circle distance between two points on the Earth's surface."""
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    distance = 6371 * c  # Earth radius in kilometers
    return int(round(1000 * distance))

def calculate_distance_matrix(locations):
    num_locations = len(locations)
    distance_matrix = [[0]*num_locations for _ in range(num_locations)]
    for i in range(num_locations):
        for j in range(num_locations):
            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']
            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']
            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)
    return distance_matrix

def create_data_model(locations, num_vehicles, depot):
    data = {}
    data["distance_matrix"] = calculate_distance_matrix(locations)
    data["num_vehicles"] = num_vehicles
    data["depot"] = depot
    return data

def print_solution(data, manager, routing, solution):
    print(f"Objective: {solution.ObjectiveValue()}")
    max_route_distance = 0
    for vehicle_id in range(data["num_vehicles"]):
        index = routing.Start(vehicle_id)
        plan_output = f"Route for vehicle {vehicle_id}:
"
        route_distance = 0
        while not routing.IsEnd(index):
            plan_output += f" {manager.IndexToNode(index)} -> "
            previous_index = index
            index = solution.Value(routing.NextVar(index))
            route_distance += routing.GetArcCostForVehicle(
                previous_index, index, vehicle_id
            )
        plan_output += f"{manager.IndexToNode(index)}
"
        plan_output += f"Distance of the route: {route_distance}m
"
        print(plan_output)
        max_route_distance = max(route_distance, max_route_distance)
    print(f"Maximum of the route distances: {max_route_distance}m")

def read_json_file(file_path):
    with open(file_path, 'r') as file:
        data = json.load(file)
        return data.get('Locations', [])

def main():
    if len(sys.argv) != 5:
        print("Wrong number of args.
Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")
        sys.exit(1)
    input_file = os.path.abspath(sys.argv[1])  # Get absolute path
    num_vehicles = int(sys.argv[2])
    depot = int(sys.argv[3])
    max_distance = int(sys.argv[4])
    locations = read_json_file(input_file)
    data = create_data_model(locations, num_vehicles, depot)
    manager = pywrapcp.RoutingIndexManager(
        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]
    )
    routing = pywrapcp.RoutingModel(manager)
    def distance_callback(from_index, to_index):
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data["distance_matrix"][from_node][to_node]
    transit_callback_index = routing.RegisterTransitCallback(distance_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
    dimension_name = "Distance"
    routing.AddDimension(
        transit_callback_index,
        0,  # no slack
        max_distance,  # vehicle maximum travel distance
        True,  # start cumul to zero
        dimension_name,
    )
    distance_dimension = routing.GetDimensionOrDie(dimension_name)
    distance_dimension.SetGlobalSpanCostCoefficient(100)
    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
    )
    solution = routing.SolveWithParameters(search_parameters)
    if solution:
        print_solution(data, manager, routing, solution)
    else:
        print("No solution found !")

if __name__ == "__main__":
    main()
Problem to be saved: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFile": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-22T11:44:26.372Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66f0031a372bf827ff2eacd7"
}
Problem saved successfully: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFile": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-22T11:44:26.372Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66f0031a372bf827ff2eacd7",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66f0031a372bf827ff2eacd7',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: {
    Locations: [
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object]
    ]
  },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 884ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:22720) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:22720) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Connected to RabbitMQ
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66ef3875b89a43c218455536',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.99983328183838,
      "Longitude": 23.74317714798427
    },
    {
      "Latitude": 37.97827880279073,
      "Longitude": 23.75884558944574
    }
  ]
}
pythonFileContent: import json
import os
import sys
from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp
from math import radians, sin, cos, sqrt, atan2

def haversine_distance(lat1, lon1, lat2, lon2):
    """Calculate the great-circle distance between two points on the Earth's surface."""
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    distance = 6371 * c  # Earth radius in kilometers
    return int(round(1000 * distance))

def calculate_distance_matrix(locations):
    num_locations = len(locations)
    distance_matrix = [[0]*num_locations for _ in range(num_locations)]
    for i in range(num_locations):
        for j in range(num_locations):
            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']
            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']
            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)
    return distance_matrix

def create_data_model(locations, num_vehicles, depot):
    data = {}
    data["distance_matrix"] = calculate_distance_matrix(locations)
    data["num_vehicles"] = num_vehicles
    data["depot"] = depot
    return data

def print_solution(data, manager, routing, solution):
    print(f"Objective: {solution.ObjectiveValue()}")
    max_route_distance = 0
    for vehicle_id in range(data["num_vehicles"]):
        index = routing.Start(vehicle_id)
        plan_output = f"Route for vehicle {vehicle_id}:
"
        route_distance = 0
        while not routing.IsEnd(index):
            plan_output += f" {manager.IndexToNode(index)} -> "
            previous_index = index
            index = solution.Value(routing.NextVar(index))
            route_distance += routing.GetArcCostForVehicle(
                previous_index, index, vehicle_id
            )
        plan_output += f"{manager.IndexToNode(index)}
"
        plan_output += f"Distance of the route: {route_distance}m
"
        print(plan_output)
        max_route_distance = max(route_distance, max_route_distance)
    print(f"Maximum of the route distances: {max_route_distance}m")

def read_json_file(file_path):
    with open(file_path, 'r') as file:
        data = json.load(file)
        return data.get('Locations', [])

def main():
    if len(sys.argv) != 5:
        print("Wrong number of args.
Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")
        sys.exit(1)
    input_file = os.path.abspath(sys.argv[1])  # Get absolute path
    num_vehicles = int(sys.argv[2])
    depot = int(sys.argv[3])
    max_distance = int(sys.argv[4])
    locations = read_json_file(input_file)
    data = create_data_model(locations, num_vehicles, depot)
    manager = pywrapcp.RoutingIndexManager(
        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]
    )
    routing = pywrapcp.RoutingModel(manager)
    def distance_callback(from_index, to_index):
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data["distance_matrix"][from_node][to_node]
    transit_callback_index = routing.RegisterTransitCallback(distance_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
    dimension_name = "Distance"
    routing.AddDimension(
        transit_callback_index,
        0,  # no slack
        max_distance,  # vehicle maximum travel distance
        True,  # start cumul to zero
        dimension_name,
    )
    distance_dimension = routing.GetDimensionOrDie(dimension_name)
    distance_dimension.SetGlobalSpanCostCoefficient(100)
    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
    )
    solution = routing.SolveWithParameters(search_parameters)
    if solution:
        print_solution(data, manager, routing, solution)
    else:
        print("No solution found !")

if __name__ == "__main__":
    main()
Problem to be saved: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFile": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-22T11:47:59.661Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66f003efde8254eebdc93c05"
}
Problem saved successfully: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFile": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-22T11:47:59.661Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66f003efde8254eebdc93c05",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66f003efde8254eebdc93c05',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 884ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:30772) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:30772) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66ef3875b89a43c218455536',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: {
    Locations: [
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object]
    ]
  },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.99983328183838,
      "Longitude": 23.74317714798427
    },
    {
      "Latitude": 37.966783510525985,
      "Longitude": 23.778605533642235
    },
    {
      "Latitude": 37.9990464764814,
      "Longitude": 23.773251398190194
    },
    {
      "Latitude": 37.974070236340665,
      "Longitude": 23.737519890565082
    },
    {
      "Latitude": 37.99763705556787,
      "Longitude": 23.76632669971703
    },
    {
      "Latitude": 37.987158185269436,
      "Longitude": 23.760040398809927
    },
    {
      "Latitude": 37.96565952612894,
      "Longitude": 23.78044816563277
    },
    {
      "Latitude": 38.00816194011881,
      "Longitude": 23.743726736188382
    },
    {
      "Latitude": 37.983474656462256,
      "Longitude": 23.73256864917707
    },
    {
      "Latitude": 37.96362413346355,
      "Longitude": 23.77785820154608
    },
    {
      "Latitude": 37.96581060070882,
      "Longitude": 23.72133687257313
    },
    {
      "Latitude": 37.97624293546459,
      "Longitude": 23.740238201740137
    },
    {
      "Latitude": 38.00566809733227,
      "Longitude": 23.728089082692076
    },
    {
      "Latitude": 38.00132387722171,
      "Longitude": 23.75830400972441
    },
    {
      "Latitude": 37.96320247915091,
      "Longitude": 23.785174964462342
    },
    {
      "Latitude": 37.965357705819066,
      "Longitude": 23.74320004992697
    },
    {
      "Latitude": 37.9692186084866,
      "Longitude": 23.785110852487332
    },
    {
      "Latitude": 37.98271697637991,
      "Longitude": 23.73542153051244
    },
    {
      "Latitude": 37.97230013076112,
      "Longitude": 23.788423933330492
    },
    {
      "Latitude": 37.97827880279073,
      "Longitude": 23.75884558944574
    }
  ]
}
pythonFileContent: import json
import os
import sys
from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp
from math import radians, sin, cos, sqrt, atan2

def haversine_distance(lat1, lon1, lat2, lon2):
    """Calculate the great-circle distance between two points on the Earth's surface."""
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    distance = 6371 * c  # Earth radius in kilometers
    return int(round(1000 * distance))

def calculate_distance_matrix(locations):
    num_locations = len(locations)
    distance_matrix = [[0]*num_locations for _ in range(num_locations)]
    for i in range(num_locations):
        for j in range(num_locations):
            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']
            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']
            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)
    return distance_matrix

def create_data_model(locations, num_vehicles, depot):
    data = {}
    data["distance_matrix"] = calculate_distance_matrix(locations)
    data["num_vehicles"] = num_vehicles
    data["depot"] = depot
    return data

def print_solution(data, manager, routing, solution):
    print(f"Objective: {solution.ObjectiveValue()}")
    max_route_distance = 0
    for vehicle_id in range(data["num_vehicles"]):
        index = routing.Start(vehicle_id)
        plan_output = f"Route for vehicle {vehicle_id}:
"
        route_distance = 0
        while not routing.IsEnd(index):
            plan_output += f" {manager.IndexToNode(index)} -> "
            previous_index = index
            index = solution.Value(routing.NextVar(index))
            route_distance += routing.GetArcCostForVehicle(
                previous_index, index, vehicle_id
            )
        plan_output += f"{manager.IndexToNode(index)}
"
        plan_output += f"Distance of the route: {route_distance}m
"
        print(plan_output)
        max_route_distance = max(route_distance, max_route_distance)
    print(f"Maximum of the route distances: {max_route_distance}m")

def read_json_file(file_path):
    with open(file_path, 'r') as file:
        data = json.load(file)
        return data.get('Locations', [])

def main():
    if len(sys.argv) != 5:
        print("Wrong number of args.
Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")
        sys.exit(1)
    input_file = os.path.abspath(sys.argv[1])  # Get absolute path
    num_vehicles = int(sys.argv[2])
    depot = int(sys.argv[3])
    max_distance = int(sys.argv[4])
    locations = read_json_file(input_file)
    data = create_data_model(locations, num_vehicles, depot)
    manager = pywrapcp.RoutingIndexManager(
        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]
    )
    routing = pywrapcp.RoutingModel(manager)
    def distance_callback(from_index, to_index):
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data["distance_matrix"][from_node][to_node]
    transit_callback_index = routing.RegisterTransitCallback(distance_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
    dimension_name = "Distance"
    routing.AddDimension(
        transit_callback_index,
        0,  # no slack
        max_distance,  # vehicle maximum travel distance
        True,  # start cumul to zero
        dimension_name,
    )
    distance_dimension = routing.GetDimensionOrDie(dimension_name)
    distance_dimension.SetGlobalSpanCostCoefficient(100)
    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
    )
    solution = routing.SolveWithParameters(search_parameters)
    if solution:
        print_solution(data, manager, routing, solution)
    else:
        print("No solution found !")

if __name__ == "__main__":
    main()
Problem to be saved: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFile": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-22T11:50:05.638Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66f0046d26b889f8b15fe60d"
}
Problem saved successfully: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFile": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-22T11:50:05.638Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66f0046d26b889f8b15fe60d",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66f0046d26b889f8b15fe60d',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: {
    Locations: [
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object]
    ]
  },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 910ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:36588) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:36588) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Connected to RabbitMQ
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66ef3875b89a43c218455536',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.99983328183838,
      "Longitude": 23.74317714798427
    },
    {
      "Latitude": 37.97827880279073,
      "Longitude": 23.75884558944574
    }
  ]
}
pythonFileContent: import json
import os
import sys
from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp
from math import radians, sin, cos, sqrt, atan2

def haversine_distance(lat1, lon1, lat2, lon2):
    """Calculate the great-circle distance between two points on the Earth's surface."""
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    distance = 6371 * c  # Earth radius in kilometers
    return int(round(1000 * distance))

def calculate_distance_matrix(locations):
    num_locations = len(locations)
    distance_matrix = [[0]*num_locations for _ in range(num_locations)]
    for i in range(num_locations):
        for j in range(num_locations):
            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']
            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']
            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)
    return distance_matrix

def create_data_model(locations, num_vehicles, depot):
    data = {}
    data["distance_matrix"] = calculate_distance_matrix(locations)
    data["num_vehicles"] = num_vehicles
    data["depot"] = depot
    return data

def print_solution(data, manager, routing, solution):
    print(f"Objective: {solution.ObjectiveValue()}")
    max_route_distance = 0
    for vehicle_id in range(data["num_vehicles"]):
        index = routing.Start(vehicle_id)
        plan_output = f"Route for vehicle {vehicle_id}:
"
        route_distance = 0
        while not routing.IsEnd(index):
            plan_output += f" {manager.IndexToNode(index)} -> "
            previous_index = index
            index = solution.Value(routing.NextVar(index))
            route_distance += routing.GetArcCostForVehicle(
                previous_index, index, vehicle_id
            )
        plan_output += f"{manager.IndexToNode(index)}
"
        plan_output += f"Distance of the route: {route_distance}m
"
        print(plan_output)
        max_route_distance = max(route_distance, max_route_distance)
    print(f"Maximum of the route distances: {max_route_distance}m")

def read_json_file(file_path):
    with open(file_path, 'r') as file:
        data = json.load(file)
        return data.get('Locations', [])

def main():
    if len(sys.argv) != 5:
        print("Wrong number of args.
Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")
        sys.exit(1)
    input_file = os.path.abspath(sys.argv[1])  # Get absolute path
    num_vehicles = int(sys.argv[2])
    depot = int(sys.argv[3])
    max_distance = int(sys.argv[4])
    locations = read_json_file(input_file)
    data = create_data_model(locations, num_vehicles, depot)
    manager = pywrapcp.RoutingIndexManager(
        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]
    )
    routing = pywrapcp.RoutingModel(manager)
    def distance_callback(from_index, to_index):
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data["distance_matrix"][from_node][to_node]
    transit_callback_index = routing.RegisterTransitCallback(distance_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
    dimension_name = "Distance"
    routing.AddDimension(
        transit_callback_index,
        0,  # no slack
        max_distance,  # vehicle maximum travel distance
        True,  # start cumul to zero
        dimension_name,
    )
    distance_dimension = routing.GetDimensionOrDie(dimension_name)
    distance_dimension.SetGlobalSpanCostCoefficient(100)
    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
    )
    solution = routing.SolveWithParameters(search_parameters)
    if solution:
        print_solution(data, manager, routing, solution)
    else:
        print("No solution found !")

if __name__ == "__main__":
    main()
Problem to be saved: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFile": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-22T11:56:08.379Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66f005d86aa6b972d7dc4447"
}
Problem saved successfully: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFile": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-22T11:56:08.379Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66f005d86aa6b972d7dc4447",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66f005d86aa6b972d7dc4447',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: { Locations: [ [Object], [Object] ] },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 913ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:37008) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:37008) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Attempting to consume from queue: problem-service-issue
Installing dependencies for Problem Management Service...

up to date, audited 155 packages in 908ms

18 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Starting Problem Management Service...
Command: cd "/c/Users/user/OneDrive - Εθνικό Μετσόβιο Πολυτεχνείο/Έγγραφα/GitHub/saasv2/saas2024-24/problem-management-service" && node app.js
(node:37052) [MONGODB DRIVER] Warning: useNewUrlParser is a deprecated option: useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
(Use `node --trace-warnings ...` to show where the warning was created)
(node:37052) [MONGODB DRIVER] Warning: useUnifiedTopology is a deprecated option: useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version
Server running on port 5000
MongoDB connected
Connected to RabbitMQ
Attempting to consume from queue: solver-to-probMan-queue
Connected to RabbitMQ
Attempting to consume from queue: problem-service-issue
Received message from queue problem-service-issue: {
  type: 'problemIssue',
  userId: '66ef3875b89a43c218455536',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: {
    Locations: [
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object]
    ]
  },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Received message type: problemIssue
Processing problem issue message...
Raw message received: {
  "type": "problemIssue",
  "userId": "66ef3875b89a43c218455536",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "locationFileContent": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFileContent": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()"
}
locationFileContent: {
  "Locations": [
    {
      "Latitude": 37.99983328183838,
      "Longitude": 23.74317714798427
    },
    {
      "Latitude": 37.966783510525985,
      "Longitude": 23.778605533642235
    },
    {
      "Latitude": 37.9990464764814,
      "Longitude": 23.773251398190194
    },
    {
      "Latitude": 37.974070236340665,
      "Longitude": 23.737519890565082
    },
    {
      "Latitude": 37.99763705556787,
      "Longitude": 23.76632669971703
    },
    {
      "Latitude": 37.987158185269436,
      "Longitude": 23.760040398809927
    },
    {
      "Latitude": 37.96565952612894,
      "Longitude": 23.78044816563277
    },
    {
      "Latitude": 38.00816194011881,
      "Longitude": 23.743726736188382
    },
    {
      "Latitude": 37.983474656462256,
      "Longitude": 23.73256864917707
    },
    {
      "Latitude": 37.96362413346355,
      "Longitude": 23.77785820154608
    },
    {
      "Latitude": 37.96581060070882,
      "Longitude": 23.72133687257313
    },
    {
      "Latitude": 37.97624293546459,
      "Longitude": 23.740238201740137
    },
    {
      "Latitude": 38.00566809733227,
      "Longitude": 23.728089082692076
    },
    {
      "Latitude": 38.00132387722171,
      "Longitude": 23.75830400972441
    },
    {
      "Latitude": 37.96320247915091,
      "Longitude": 23.785174964462342
    },
    {
      "Latitude": 37.965357705819066,
      "Longitude": 23.74320004992697
    },
    {
      "Latitude": 37.9692186084866,
      "Longitude": 23.785110852487332
    },
    {
      "Latitude": 37.98271697637991,
      "Longitude": 23.73542153051244
    },
    {
      "Latitude": 37.97230013076112,
      "Longitude": 23.788423933330492
    },
    {
      "Latitude": 37.97827880279073,
      "Longitude": 23.75884558944574
    }
  ]
}
pythonFileContent: import json
import os
import sys
from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp
from math import radians, sin, cos, sqrt, atan2

def haversine_distance(lat1, lon1, lat2, lon2):
    """Calculate the great-circle distance between two points on the Earth's surface."""
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    distance = 6371 * c  # Earth radius in kilometers
    return int(round(1000 * distance))

def calculate_distance_matrix(locations):
    num_locations = len(locations)
    distance_matrix = [[0]*num_locations for _ in range(num_locations)]
    for i in range(num_locations):
        for j in range(num_locations):
            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']
            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']
            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)
    return distance_matrix

def create_data_model(locations, num_vehicles, depot):
    data = {}
    data["distance_matrix"] = calculate_distance_matrix(locations)
    data["num_vehicles"] = num_vehicles
    data["depot"] = depot
    return data

def print_solution(data, manager, routing, solution):
    print(f"Objective: {solution.ObjectiveValue()}")
    max_route_distance = 0
    for vehicle_id in range(data["num_vehicles"]):
        index = routing.Start(vehicle_id)
        plan_output = f"Route for vehicle {vehicle_id}:
"
        route_distance = 0
        while not routing.IsEnd(index):
            plan_output += f" {manager.IndexToNode(index)} -> "
            previous_index = index
            index = solution.Value(routing.NextVar(index))
            route_distance += routing.GetArcCostForVehicle(
                previous_index, index, vehicle_id
            )
        plan_output += f"{manager.IndexToNode(index)}
"
        plan_output += f"Distance of the route: {route_distance}m
"
        print(plan_output)
        max_route_distance = max(route_distance, max_route_distance)
    print(f"Maximum of the route distances: {max_route_distance}m")

def read_json_file(file_path):
    with open(file_path, 'r') as file:
        data = json.load(file)
        return data.get('Locations', [])

def main():
    if len(sys.argv) != 5:
        print("Wrong number of args.
Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")
        sys.exit(1)
    input_file = os.path.abspath(sys.argv[1])  # Get absolute path
    num_vehicles = int(sys.argv[2])
    depot = int(sys.argv[3])
    max_distance = int(sys.argv[4])
    locations = read_json_file(input_file)
    data = create_data_model(locations, num_vehicles, depot)
    manager = pywrapcp.RoutingIndexManager(
        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]
    )
    routing = pywrapcp.RoutingModel(manager)
    def distance_callback(from_index, to_index):
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data["distance_matrix"][from_node][to_node]
    transit_callback_index = routing.RegisterTransitCallback(distance_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
    dimension_name = "Distance"
    routing.AddDimension(
        transit_callback_index,
        0,  # no slack
        max_distance,  # vehicle maximum travel distance
        True,  # start cumul to zero
        dimension_name,
    )
    distance_dimension = routing.GetDimensionOrDie(dimension_name)
    distance_dimension.SetGlobalSpanCostCoefficient(100)
    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
    )
    solution = routing.SolveWithParameters(search_parameters)
    if solution:
        print_solution(data, manager, routing, solution)
    else:
        print("No solution found !")

if __name__ == "__main__":
    main()
Problem to be saved: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFile": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-22T12:10:30.678Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66f009369538cb7f6406f023"
}
Problem saved successfully: {
  "userId": "66ef3875b89a43c218455536",
  "locationFile": {
    "Locations": [
      {
        "Latitude": 37.99983328183838,
        "Longitude": 23.74317714798427
      },
      {
        "Latitude": 37.966783510525985,
        "Longitude": 23.778605533642235
      },
      {
        "Latitude": 37.9990464764814,
        "Longitude": 23.773251398190194
      },
      {
        "Latitude": 37.974070236340665,
        "Longitude": 23.737519890565082
      },
      {
        "Latitude": 37.99763705556787,
        "Longitude": 23.76632669971703
      },
      {
        "Latitude": 37.987158185269436,
        "Longitude": 23.760040398809927
      },
      {
        "Latitude": 37.96565952612894,
        "Longitude": 23.78044816563277
      },
      {
        "Latitude": 38.00816194011881,
        "Longitude": 23.743726736188382
      },
      {
        "Latitude": 37.983474656462256,
        "Longitude": 23.73256864917707
      },
      {
        "Latitude": 37.96362413346355,
        "Longitude": 23.77785820154608
      },
      {
        "Latitude": 37.96581060070882,
        "Longitude": 23.72133687257313
      },
      {
        "Latitude": 37.97624293546459,
        "Longitude": 23.740238201740137
      },
      {
        "Latitude": 38.00566809733227,
        "Longitude": 23.728089082692076
      },
      {
        "Latitude": 38.00132387722171,
        "Longitude": 23.75830400972441
      },
      {
        "Latitude": 37.96320247915091,
        "Longitude": 23.785174964462342
      },
      {
        "Latitude": 37.965357705819066,
        "Longitude": 23.74320004992697
      },
      {
        "Latitude": 37.9692186084866,
        "Longitude": 23.785110852487332
      },
      {
        "Latitude": 37.98271697637991,
        "Longitude": 23.73542153051244
      },
      {
        "Latitude": 37.97230013076112,
        "Longitude": 23.788423933330492
      },
      {
        "Latitude": 37.97827880279073,
        "Longitude": 23.75884558944574
      }
    ]
  },
  "pythonFile": "import json\nimport os\nimport sys\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nfrom math import radians, sin, cos, sqrt, atan2\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    \"\"\"Calculate the great-circle distance between two points on the Earth's surface.\"\"\"\n    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = 6371 * c  # Earth radius in kilometers\n    return int(round(1000 * distance))\n\ndef calculate_distance_matrix(locations):\n    num_locations = len(locations)\n    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n    for i in range(num_locations):\n        for j in range(num_locations):\n            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n    return distance_matrix\n\ndef create_data_model(locations, num_vehicles, depot):\n    data = {}\n    data[\"distance_matrix\"] = calculate_distance_matrix(locations)\n    data[\"num_vehicles\"] = num_vehicles\n    data[\"depot\"] = depot\n    return data\n\ndef print_solution(data, manager, routing, solution):\n    print(f\"Objective: {solution.ObjectiveValue()}\")\n    max_route_distance = 0\n    for vehicle_id in range(data[\"num_vehicles\"]):\n        index = routing.Start(vehicle_id)\n        plan_output = f\"Route for vehicle {vehicle_id}:\n\"\n        route_distance = 0\n        while not routing.IsEnd(index):\n            plan_output += f\" {manager.IndexToNode(index)} -> \"\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(\n                previous_index, index, vehicle_id\n            )\n        plan_output += f\"{manager.IndexToNode(index)}\n\"\n        plan_output += f\"Distance of the route: {route_distance}m\n\"\n        print(plan_output)\n        max_route_distance = max(route_distance, max_route_distance)\n    print(f\"Maximum of the route distances: {max_route_distance}m\")\n\ndef read_json_file(file_path):\n    with open(file_path, 'r') as file:\n        data = json.load(file)\n        return data.get('Locations', [])\n\ndef main():\n    if len(sys.argv) != 5:\n        print(\"Wrong number of args.\nUsage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>\")\n        sys.exit(1)\n    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n    num_vehicles = int(sys.argv[2])\n    depot = int(sys.argv[3])\n    max_distance = int(sys.argv[4])\n    locations = read_json_file(input_file)\n    data = create_data_model(locations, num_vehicles, depot)\n    manager = pywrapcp.RoutingIndexManager(\n        len(data[\"distance_matrix\"]), data[\"num_vehicles\"], data[\"depot\"]\n    )\n    routing = pywrapcp.RoutingModel(manager)\n    def distance_callback(from_index, to_index):\n        from_node = manager.IndexToNode(from_index)\n        to_node = manager.IndexToNode(to_index)\n        return data[\"distance_matrix\"][from_node][to_node]\n    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n    dimension_name = \"Distance\"\n    routing.AddDimension(\n        transit_callback_index,\n        0,  # no slack\n        max_distance,  # vehicle maximum travel distance\n        True,  # start cumul to zero\n        dimension_name,\n    )\n    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n    distance_dimension.SetGlobalSpanCostCoefficient(100)\n    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n    search_parameters.first_solution_strategy = (\n        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n    )\n    solution = routing.SolveWithParameters(search_parameters)\n    if solution:\n        print_solution(data, manager, routing, solution)\n    else:\n        print(\"No solution found !\")\n\nif __name__ == \"__main__\":\n    main()",
  "numVehicles": 3,
  "depot": 0,
  "maxDistance": 50,
  "submissionDate": "2024-09-22T12:10:30.678Z",
  "status": "pending",
  "hasSolution": false,
  "solution": "",
  "maxRouteDistance": 0,
  "totalDistTravel": 0,
  "executionDuration": 0,
  "_id": "66f009369538cb7f6406f023",
  "__v": 0
}
Sending message to queue probMan-to-solver-queue: {
  problemId: '66f009369538cb7f6406f023',
  numVehicles: 3,
  depot: 0,
  maxDistance: 50,
  locationFileContent: {
    Locations: [
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object], [Object],
      [Object], [Object]
    ]
  },
  pythonFileContent: 'import json\n' +
    'import os\n' +
    'import sys\n' +
    'from ortools.constraint_solver import routing_enums_pb2\n' +
    'from ortools.constraint_solver import pywrapcp\n' +
    'from math import radians, sin, cos, sqrt, atan2\n' +
    '\n' +
    'def haversine_distance(lat1, lon1, lat2, lon2):\n' +
    `    """Calculate the great-circle distance between two points on the Earth's surface."""\n` +
    '    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n' +
    '    dlat = lat2 - lat1\n' +
    '    dlon = lon2 - lon1\n' +
    '    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n' +
    '    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n' +
    '    distance = 6371 * c  # Earth radius in kilometers\n' +
    '    return int(round(1000 * distance))\n' +
    '\n' +
    'def calculate_distance_matrix(locations):\n' +
    '    num_locations = len(locations)\n' +
    '    distance_matrix = [[0]*num_locations for _ in range(num_locations)]\n' +
    '    for i in range(num_locations):\n' +
    '        for j in range(num_locations):\n' +
    "            lat1, lon1 = locations[i]['Latitude'], locations[i]['Longitude']\n" +
    "            lat2, lon2 = locations[j]['Latitude'], locations[j]['Longitude']\n" +
    '            distance_matrix[i][j] = haversine_distance(lat1, lon1, lat2, lon2)\n' +
    '    return distance_matrix\n' +
    '\n' +
    'def create_data_model(locations, num_vehicles, depot):\n' +
    '    data = {}\n' +
    '    data["distance_matrix"] = calculate_distance_matrix(locations)\n' +
    '    data["num_vehicles"] = num_vehicles\n' +
    '    data["depot"] = depot\n' +
    '    return data\n' +
    '\n' +
    'def print_solution(data, manager, routing, solution):\n' +
    '    print(f"Objective: {solution.ObjectiveValue()}")\n' +
    '    max_route_distance = 0\n' +
    '    for vehicle_id in range(data["num_vehicles"]):\n' +
    '        index = routing.Start(vehicle_id)\n' +
    '        plan_output = f"Route for vehicle {vehicle_id}:\n' +
    '"\n' +
    '        route_distance = 0\n' +
    '        while not routing.IsEnd(index):\n' +
    '            plan_output += f" {manager.IndexToNode(index)} -> "\n' +
    '            previous_index = index\n' +
    '            index = solution.Value(routing.NextVar(index))\n' +
    '            route_distance += routing.GetArcCostForVehicle(\n' +
    '                previous_index, index, vehicle_id\n' +
    '            )\n' +
    '        plan_output += f"{manager.IndexToNode(index)}\n' +
    '"\n' +
    '        plan_output += f"Distance of the route: {route_distance}m\n' +
    '"\n' +
    '        print(plan_output)\n' +
    '        max_route_distance = max(route_distance, max_route_distance)\n' +
    '    print(f"Maximum of the route distances: {max_route_distance}m")\n' +
    '\n' +
    'def read_json_file(file_path):\n' +
    "    with open(file_path, 'r') as file:\n" +
    '        data = json.load(file)\n' +
    "        return data.get('Locations', [])\n" +
    '\n' +
    'def main():\n' +
    '    if len(sys.argv) != 5:\n' +
    '        print("Wrong number of args.\n' +
    'Usage: python <script_name.py> <input_file.json> <num_vehicles> <depot> <max_distance>")\n' +
    '        sys.exit(1)\n' +
    '    input_file = os.path.abspath(sys.argv[1])  # Get absolute path\n' +
    '    num_vehicles = int(sys.argv[2])\n' +
    '    depot = int(sys.argv[3])\n' +
    '    max_distance = int(sys.argv[4])\n' +
    '    locations = read_json_file(input_file)\n' +
    '    data = create_data_model(locations, num_vehicles, depot)\n' +
    '    manager = pywrapcp.RoutingIndexManager(\n' +
    '        len(data["distance_matrix"]), data["num_vehicles"], data["depot"]\n' +
    '    )\n' +
    '    routing = pywrapcp.RoutingModel(manager)\n' +
    '    def distance_callback(from_index, to_index):\n' +
    '        from_node = manager.IndexToNode(from_index)\n' +
    '        to_node = manager.IndexToNode(to_index)\n' +
    '        return data["distance_matrix"][from_node][to_node]\n' +
    '    transit_callback_index = routing.RegisterTransitCallback(distance_callback)\n' +
    '    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n' +
    '    dimension_name = "Distance"\n' +
    '    routing.AddDimension(\n' +
    '        transit_callback_index,\n' +
    '        0,  # no slack\n' +
    '        max_distance,  # vehicle maximum travel distance\n' +
    '        True,  # start cumul to zero\n' +
    '        dimension_name,\n' +
    '    )\n' +
    '    distance_dimension = routing.GetDimensionOrDie(dimension_name)\n' +
    '    distance_dimension.SetGlobalSpanCostCoefficient(100)\n' +
    '    search_parameters = pywrapcp.DefaultRoutingSearchParameters()\n' +
    '    search_parameters.first_solution_strategy = (\n' +
    '        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n' +
    '    )\n' +
    '    solution = routing.SolveWithParameters(search_parameters)\n' +
    '    if solution:\n' +
    '        print_solution(data, manager, routing, solution)\n' +
    '    else:\n' +
    '        print("No solution found !")\n' +
    '\n' +
    'if __name__ == "__main__":\n' +
    '    main()'
}
Message successfully sent to queue: probMan-to-solver-queue
Message sent to solver queue
Message from queue problem-service-issue acknowledged.
